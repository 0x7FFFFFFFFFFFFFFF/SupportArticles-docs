**Part 3.3 - Debuggers, core dumps and collecting core dumps\
\
Prerequisites**

 

Like the two chapters that preceded it, this part is structured to place
more emphasis on the theory and principals to follow when starting to
troubleshoot. It does not have any prerequisites, but you should have
following set up at the moment if you followed all the steps of this
training so far:

 

-   Nginx has two web sites:

    -   The first web site listening for requests with the
        > **myfirstwebsite** host header
        > ([[http://myfirstwebsite]{.ul}](http://myfirstwebsite)) and
        > routing the requests to the demo ASP.NET Core application
        > which is listening on port 5000.

    -   The second web site listening for requests with host header
        > **buggyamb** ([[http://buggyamb]{.ul}](http://buggyamb)) and
        > routing the requests to the second ASP.NET Core sample buggy
        > application which is listening on port 5001.

-   Both ASP.NET Core applications should be running as services which
    > restart automatically when the server is rebooted, or the
    > applications stops or crashes.

-   Linux local firewall is enabled and configured to allow SSH and HTTP
    > traffic.

 

**Goal of this part**

 

This part is aimed at introducing you to the concept of core dumps,
debuggers, and the tools to capture and analyze core dump files. Most of
the techniques and tools described in this part will be used in the next
troubleshooting labs.

 

**Core dump**

 

Just like a user mode memory dump in Windows, a [[core
dump]{.ul}](https://en.wikipedia.org/wiki/Core_dump) is a snapshot of
the memory of a process. Core dumps are frequently needed for
troubleshooting crash or performance problems in Linux.

 

A core dump can be generated on-demand by a debugger (manual dump
collection) or can be configured to be collected automatically after a
process crash.

 

**What happens when a process crashes in Linux?**

 

Most Linux systems have core dumps enabled by default and systemd
generates a core dump for any process when it is terminated
unexpectedly. This is much like the way in which Windows Error Reporting
(WER) in Windows generates dumps for processes that terminate
abnormally.

 

Here are some key behaviors of a Linux system related to core dumps
generation:

 

-   By default, a core dump is generated when a process is terminated
    > unexpectedly.

-   The Core dump file is named as **core** and is created in current
    > the working directory or in /var/lib/systemd/coredump directory.

-   Although the default behavior is for the operating system to
    > generate a core dump, this setting can be overwritten in
    > **/proc/sys/kernel/core_pattern** to directly pipe the core dump
    > into another application.

 

These defaults along with some other settings such as the size limits
can be configured using configuration files. The following resources go
into greater depth of this subject:

 

> Core dumps:
>
> [[https://wiki.archlinux.org/index.php/Core_dump]{.ul}](https://wiki.archlinux.org/index.php/Core_dump)

 

> Ubuntu man page core - core dump file:
>
> [[http://manpages.ubuntu.com/manpages/precise/man5/core.5.html]{.ul}](http://manpages.ubuntu.com/manpages/precise/man5/core.5.html)

 

**Apport - Ubuntu\'s way to manage core dumps**

 

In Ubuntu, there is [[apport]{.ul}](https://wiki.ubuntu.com/Apport)
which runs as a system service to manage core dump generation and even
if the operating system\'s core dump generation is disabled, apport will
still create coredump files.

 

According to the default documentation, apport
uses **/proc/sys/kernel/core_pattern** to directly pipe the core dump
into apport. If you run the **cat /proc/sys/kernel/core_pattern**
command, when apport is running, you should see the following:

 

![](media/image1.png){width="6.268055555555556in"
height="0.6986111111111111in"}

 

If you disable apport, this will not disable core dump generation on
process termination, it will just stop apport and the system behave in
line with the default behavior where core dumps are generated by system.
If you run the same **cat /proc/sys/kernel/core_pattern** after apport
is stopped, you will see the following which is the default system
behavior:

 

![](media/image2.png){width="6.268055555555556in"
height="0.8381944444444445in"}

 

**Disabling automatic core dump generation**

 

Even if you configure the operating system to stop generating core dump
files, these will be generated by apport if it is running. To start, do
the following two things:

 

1.  Stop and disable apport.

2.  Disable system\'s behavior.

 

Apport can be stopped and disabled just like any other service. Use the
**sudo systemctl stop apport** command and the **sudo systemctl disable
apport** commands to stop and then disable this service to prevent it
from being restarted:

 

![](media/image3.png){width="6.268055555555556in"
height="0.9590277777777778in"}

 

To disable the operating system\'s automatic dump generation for all
processes running under all user accounts on the machine you have to
take the steps that are clearly outlined in several articles, [[such as
this one]{.ul}](https://wiki.archlinux.org/index.php/Core_dump), on the
Internet.

 

**Capturing core dump and debuggers**

 

There are several tools to capture a core dump such as
[**[gcore]{.ul}**](https://www.linux.org/docs/man1/gcore.html), gdb, and
several tools to analyze a core dump, such as
[**[objdump]{.ul}**](https://en.wikipedia.org/wiki/Objdump),
[**[kdump]{.ul}**](https://en.wikipedia.org/wiki/Kdump_(Linux)),
[**[gdb]{.ul}**](https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/)
and [**[lldb]{.ul}**](https://en.wikipedia.org/wiki/LLDB_(debugger)).

 

However, there are some important difficulties when working with these
tools and attempting to perform .Net debugging:

 

-   Configuration could be very difficult when compared with the process
    > of setting up symbols for the WinDbg debugger on Windows.

-   Core dump files are large because these tools do not know which
    > memory region is used in a .NET Core process and cannot trim the
    > memory information to only what is needed.

-   Dumps are not portable: you will need to analyze the dumps in the
    > Linux machine where they were generated. If you want to analyze
    > the dump in on different Linux machine, then extra steps need to
    > be taken to configure the host machine for the debugging session.

 

**lldb**

 

[**[lldb]{.ul}**](https://en.wikipedia.org/wiki/LLDB_(debugger)) is the
recommend tool for analyzing dotnet core dumps and the dotnet SDK
includes useful tools to configure lldb correctly. However, you need to
install at least version 3.9 to be able to perform such debug analysis
for .Net Core.

 

To install lldb 3.9 or later, use package manager (e.g.: **sudo apt
install lldb**).

 

**Tools and commands available in the .NET Core runtime and SDK**

 

There are some useful tools that come with .NET Core runtime. For
example, createdump is installed with every runtime installation of .Net
Core.

 

There are also \"tools\" that can be installed. You can also develop
your own tools or chose to make use of several tools developed by third
parties. The Microsoft .Net Core plateform also comes with some .NET
Core tools that are very helpful when debugging .NET Core problems. Some
of them are listed below:

 

-   dotnet-dump

-   dotnet-gcdump

-   dotnet-symbol

 

To install these tools along with the other ones, you need to have .NET
Core SDK installed. To get more information about .NET Core SDK, please
check the following site:
[[https://docs.microsoft.com/en-us/dotnet/core/sdk]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/sdk)

> **Note: procdump** should be mentioned as well although it is not part
> of SDK. An in-depth discussion of procdump options can be found at the
> end of this chapter.

 

**createdump**

 

createdump is installed with every .NET Core version. The implementation
details are explained
[[here]{.ul}](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md).

 

The best way to generate a crash core dump in Linux is to use createdump
because the dumps generated automatically by system may not have all the
managed state and some SOS or dotnet-dump commands may display
\"UNKNOWN\" for type and function names.

 

Similarly, the manual dumps created with gdb or gcore will not have all
the managed state information and some SOS or dotnet-dump commands may
display \"UNKNOWN\" for type and function names as well. The recommend
way to capture manual dumps is using either createdump or other dotnet
tools, inluding procdump.

 

Here are some important features of createdump:

 

-   Automatic generation of minimal size minidumps.

-   Easy to configure with a non-root user.

-   Can be used to capture on-demand (manual) or crash core dumps.

-   Most of the stack overflow crashes are detected.

 

You need to use lldb 3.9 or later to analyze the core dump files
captured with createdump.

 

createdump can be found in .NET Core installation directory. To find the
.NET Core installation directories run the **dotnet \--list-runtimes**
command. As seen in the screenshot below, I have two runtimes running so
I have two createdump file for both versions:

 

![](media/image4.png){width="6.268055555555556in" height="1.59375in"}

 

**dotnet-dump**

 

You need to have .NET Core SDK installed to be able to install this
tool.
[[dotnet-dump]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump)
was introduced with the .NET Core 3.0 SDK and later versions and it
helps collecting and analyzing core dumps **[without]{.ul}** any native
debugger. It allows you to run SOS commands to analyze crashes and the
garbage collector (GC).

 

Note that it is not a native debugger, so some features such as
displaying the native stack frames are not available. The dump generated
is not portable and you cannot open it in Windows.

 

To install this tool, you need to run the following command:

 

> **dotnet tool install -g dotnet-dump**

 

We will use this tool to capture and analyze core dumps in the upcoming
lab sections.

 

**dotnet-gcdump**

 

This is another tool that requires .NET Core SDK.
[[dotnet-gcdump]{.ul}](https://devblogs.microsoft.com/dotnet/collecting-and-analyzing-memory-dumps/)
is available in .NET Core [3.1]{.ul} or later versions.

 

This is an interesting approach for analyzing GC heaps. The idea behind
this tool is that a full process dump is not required for investigations
in many scenarios, so the tool captures only the managed heap
information and generates a report based on it.

 

Most importantly, the dump files generated by this tool are **portable**
and can be analyzed in PerfView or Visual Studio in Windows.

 

As briefly explained
[[here]{.ul}](https://devblogs.microsoft.com/dotnet/collecting-and-analyzing-memory-dumps/),
a full GC is triggered with this tool to stream the information to an
\"event pipe\" to generate the dump file. Note that since a full Gen 2
GC is triggered in the target process, the performance characteristics
of the application can be changed and as expected, while the information
is written to the core dump file the threads will be suspended. The
larger the heap size the longer pauses to write the information to the
file and the longer the threads will stay paused.

These information contained inside such core dumps will be useful when:

 

-   Comparing number of objects by type on the managed heap

-   Analyzing object roots

-   Finding what objects have a reference to what type

-   Other statistical analysis about objects on the heap

 

Once the data is generated the file can be exported outside of the
machine where it was created, and it can be analyzed in PerfView or in
Visual Studio.

 

To install this tool you need to run the following command:

 

> **dotnet tool install -g dotnet-gcdump**

 

We will use to generate some reports for .NET Core heaps in the upcoming
lab sections.

 

**dotnet-symbol**

 

[[dotnet-symbol]{.ul}](http://dotnet-symbol) is a very useful tool for
getting symbols for managed debugging and was introduced in .NET Core
2.1 or later. Just like the two other tools detailed above, this also
requires .NET Core SDK to be installed.

 

dotnet-symbol downloads all the files needed for debugging (symbols,
modules, SOS and DAC for the coreclr module) for any given core dump.

 

To install this tool, you need to run the following command:

 

> **dotnet tool install -g dotnet-symbol**

 

We will use this tool to configure debugger in the upcoming lab
sections.

 

**procdump**

 

[[A linux version of
procdump]{.ul}](https://github.com/Microsoft/ProcDump-for-Linux) is also
available with some limited feature sets compared to its Windows
counterpart. It does not support every feature the Windows version has.
For example, it cannot be configured to collect core dumps when the
process crashes or throws a first chance exception.

 

However it is still a quite powerful tool. The following command line
options should give you a preview of what it can be used for:

 

> -C: Trigger core dump generation when CPU exceeds or equals specified
> value (0 to 100 \* nCPU)
>
> -c: Trigger core dump generation when CPU is less than specified value
> (0 to 100 \* nCPU)
>
> -M: Trigger core dump generation when memory commit exceeds or equals
> specified value (MB)
>
> -m: Trigger core dump generation when when memory commit is less than
> specified value (MB)
>
> -T: Trigger when thread count exceeds or equals specified value.
>
> -F: Trigger when filedescriptor count exceeds or equals specified
> value.

 

Please follow the [[installation
instructions]{.ul}](https://github.com/microsoft/ProcDump-for-Linux/blob/master/INSTALL.md)
to install procdump in your environment.

 

We will use this tool to capture a core dump based on CPU usage in the
upcoming lab sections.

 

**A note about selecting the SDK version to use**

 

By default, the SDK installs in a \"side-by-side\" which means multiple
versions can run together on a single machine. How the version gets
picked when you\'re running CLI commands is explained in more detail in
the [[Select the .NET Core version to
use]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/versions/selection)
article. As explained in the article the process for selecting an SDK
version can be summarized like below:

 

-   dotnet searches for a global.json file iteratively reverse
    > navigating the path upward from the current working directory.

-   dotnet uses the SDK specified in the first global.json found.

-   dotnet uses the latest installed SDK if no global.json is found.

 

For example, on the test Linux virtual machine you should have both the
.NET Core 3.1 and 5.0 SDKs installed. If you run dotnet with \--version
switch, you should see that the latest version is being used:

 

![](media/image5.png){width="6.268055555555556in"
height="1.0798611111111112in"}

 

Now create a global.json file in the current directory which is your
home directory and set the version explicitly using the cat tool as
shown below. Then check the version once again and it is now showing the
exact SDK version you placed inside the global.json file:

 

![](media/image6.png){width="6.268055555555556in"
height="1.4479166666666667in"}

 

This is important to know when you run some SDK commands such as
creating new application with dotnet new command. However, mostly you
won\'t need to do this when working with dotnet-dump and dotnet-gcdump
tools.

 

.NET Core SDK will install the latest version of the tools no matter
which SDK you have selected. For example, if you have executed the
commands to install the dotnet-dump, dotnet-gcdump and dotnet-symbol
tools when the .NET Core SDK 3.1 is selected, the latest versions of
these tools will be downloaded and installed as seen in the screenshot
below (where version 5 of the tools for dotnet-dump and dotnet-gcdump
have been installed):

 

![](media/image7.png){width="6.268055555555556in"
height="1.2194444444444446in"}

 

Following articles are great resources to continue reading about .NET
tools:

 

> How to manage .NET tools
>
> [[https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools)
>
>  
>
> dotnet tool install
>
> [[https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-tool-install]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-tool-install)

 

Note that, selecting the runtime version to use is different than
selecting the SDK version. If you want to use a specific version of the
.NET Runtime, use the \--fx-version \<VERSION\> option as explained in
[[this
article]{.ul}](https://docs.microsoft.com/en-us/dotnet/core/tools/).

 

You are now ready to continue with troubleshooting labs. You will learn
how to use these tools to troubleshoot problems in the next chapters.
