---
title: Debuggers, core dumps and collecting core dumps
description: This article describes the debuggers, core dumps, and the tools to capture and analyze core dump files in Linux.
ms.date: 03/25/2021
ms.prod: aspnet-core
ms.reviewer: ramakoni
---
# Part 3.3 - Debuggers, core dumps and collecting core dumps

_Applies to:_ &nbsp; .NET Core 2.1, .NET Core 3.1  

This article introduces the debuggers, core dumps, and the tools to capture and analyze core dump files in Linux.

[!INCLUDE [Prerequisites](prerequisites.md)]

## Goal of this part

This part is aimed at introducing you to the concept of core dumps, debuggers, and the tools to capture and analyze core dump files. Most of the techniques and tools described in this part will be used in the next troubleshooting labs.

## Core dump

Just like a user mode memory dump in Windows, a [core dump](https://wikipedia.org/wiki/Core_dump) is a snapshot of the memory of a process. Core dumps are frequently needed for troubleshooting crash or performance problems in Linux.

A core dump can be generated on-demand by a debugger (manual dump collection) or can be configured to be collected automatically after a process crash.

## What happens when a process crashes in Linux?

Most Linux systems have core dumps enabled by default and systemd generates a core dump for any process when it is terminated unexpectedly. This is much like the way in which Windows Error Reporting (WER) in Windows generates dumps for processes that terminate abnormally.

Here are some key behaviors of a Linux system related to core dumps generation:

- By default, a core dump is generated when a process is terminated unexpectedly.
- The Core dump file is named as core and is created in current the working directory or in *:::no-loc text="/var/lib/systemd/coredump":::* directory.
- Although the default behavior is for the operating system to generate a core dump, this setting can be overwritten in *:::no-loc text="/proc/sys/kernel/core_pattern":::* to directly pipe the core dump into another application.

These defaults along with some other settings such as the size limits can be configured using configuration files. The following resources go into greater depth of this subject:

- [Core dumps](https://wiki.archlinux.org/index.php/Core_dump)

- [Ubuntu man page core - core dump file](https://manpages.ubuntu.com/manpages/precise/man5/core.5.html)

## Apport - Ubuntu's way to manage core dumps

In Ubuntu, there is [apport](https://wiki.ubuntu.com/Apport) which runs as a system service to manage core dump generation and even if the operating system's core dump generation is disabled, apport will still create coredump files.

According to the default documentation, apport uses *:::no-loc text="/proc/sys/kernel/core_pattern":::* to directly pipe the core dump into apport. If you run the `cat /proc/sys/kernel/core_pattern` command, when apport is running, you should see the following:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/core.png" alt-text="BuggyAmb core" border="true":::

If you disable apport, this will not disable core dump generation on process termination, it will just stop apport and the system behave in line with the default behavior where core dumps are generated by system. If you run the same `cat /proc/sys/kernel/core_pattern` after apport is stopped, you will see the following, which is the default system behavior:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/cat.png" alt-text="BuggyAmb cat" border="true":::

## Disabling automatic core dump generation

Even if you configure the operating system to stop generating core dump files, these will be generated by apport if it is running. To start, do the following two things:

1. Stop and disable apport.
2. Disable system's behavior.

Apport can be stopped and disabled just like any other service. Use the `sudo systemctl stop apport` command and the `sudo systemctl disable apport` commands to stop and then disable this service to prevent it from being restarted:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/stop.png" alt-text="BuggyAmb stop" border="true":::

To disable the operating system's automatic dump generation for all processes running under all user accounts on the machine you have to take the steps that are clearly outlined in several articles, [such as this one](https://wiki.archlinux.org/index.php/Core_dump), on the Internet.

## Capturing core dump and debuggers

There are several tools to capture a core dump such as [gcore](https://www.linux.org/docs/man1/gcore.html), gdb, and several tools to analyze a core dump, such as [objdump](https://wikipedia.org/wiki/Objdump), [kdump](https://wikipedia.org/wiki/Kdump_(Linux)), [gdb](https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/) and [lldb](https://wikipedia.org/wiki/LLDB_(debugger)).

However, there are some important difficulties when working with these tools and attempting to perform .NET debugging:

- Configuration could be difficult when compared with the process of setting up symbols for the WinDbg debugger on Windows.
- Core dump files are large because these tools do not know which memory region is used in a .NET Core process and cannot trim the memory information to only what is needed.
- Dumps are not portable: you will need to analyze the dumps in the Linux machine where they were generated. If you want to analyze the dump in on different Linux machine, then extra steps need to be taken to configure the host machine for the debugging session.

## lldb

[lldb](https://wikipedia.org/wiki/LLDB_(debugger)) is the recommend tool for analyzing dotnet core dumps and the dotnet SDK includes useful tools to configure lldb correctly. However, you need to install at least version 3.9 to be able to perform such debug analysis for .NET Core.

To install lldb 3.9 or later, use package manager (for example: `sudo apt install lldb`).

## Tools and commands available in the .NET Core runtime and SDK

There are some useful tools that come with .NET Core runtime. For example, createdump is installed with every runtime installation of .NET Core.

There are also "tools" that can be installed. You can also develop your own tools or chose to make use of several tools developed by third parties. The Microsoft .NET Core platform also comes with some .NET Core tools that are helpful when debugging .NET Core problems. Some of them are listed below:

- dotnet-dump
- dotnet-gcdump
- dotnet-symbol

To install these tools along with the other ones, you need to have .NET Core SDK installed. To get more information about .NET Core SDK, see: [.NET SDK overview](/dotnet/core/sdk).

> [!NOTE]
> procdump should be mentioned as well although it is not part of SDK. An in-depth discussion of procdump options can be found at the end of this chapter.

## createdump

createdump is installed with every .NET Core version. The implementation details are explained [here](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md).

The best way to generate a crash core dump in Linux is to use createdump because the dumps generated automatically by system may not have all the managed state and some SOS or dotnet-dump commands may display "UNKNOWN" for type and function names.

Similarly, the manual dumps created with gdb or gcore will not have all the managed state information and some SOS or dotnet-dump commands may display "UNKNOWN" for type and function names as well. The recommend way to capture manual dumps is using either createdump or other dotnet tools, including procdump.

Here are some important features of createdump:

- Automatic generation of minimal size minidumps.
- Easy to configure with a non-root user.
- Can be used to capture on-demand (manual) or crash core dumps.
- Most of the stack overflow crashes are detected.

You need to use lldb 3.9 or later to analyze the core dump files captured with createdump.

createdump can be found in .NET Core installation directory. To find the .NET Core installation directories, run the `dotnet --list-runtimes` command. As seen in the screenshot below, I have two runtimes running so I have two createdump file for both versions:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/dotnet.png" alt-text="BuggyAmb dotnet" border="true":::

## dotnet-dump

You need to have .NET Core SDK installed to be able to install this tool. [dotnet-dump](/dotnet/core/diagnostics/dotnet-dump) was introduced with the .NET Core 3.0 SDK and later versions and it helps collecting and analyzing core dumps without any native debugger. It allows you to run SOS commands to analyze crashes and the garbage collector (GC).

> [!NOTE]
> It is not a native debugger, so some features such as displaying the native stack frames are not available. The dump generated is not portable and you cannot open it in Windows.

To install this tool, you need to run the following command:

```dotnetcli
dotnet tool install -g dotnet-dump
```

We will use this tool to capture and analyze core dumps in the upcoming lab sections.

## dotnet-gcdump

This is another tool that requires .NET Core SDK. [dotnet-gcdump](https://devblogs.microsoft.com/dotnet/collecting-and-analyzing-memory-dumps/) is available in .NET Core 3.1 or later versions.

This is an interesting approach for analyzing GC heaps. The idea behind this tool is that a full process dump is not required for investigations in many scenarios, so the tool captures only the managed heap information and generates a report based on it.

Most importantly, the dump files generated by this tool are portable and can be analyzed in PerfView or Visual Studio in Windows.

As briefly explained [here](https://devblogs.microsoft.com/dotnet/collecting-and-analyzing-memory-dumps/), a full GC is triggered with this tool to stream the information to an "event pipe" to generate the dump file.

> [!NOTE]
> Since a full Gen 2 GC is triggered in the target process, the performance characteristics of the application can be changed and as expected, while the information is written to the core dump file the threads will be suspended. The larger the heap size the longer pauses to write the information to the file and the longer the threads will stay paused.

These information contained inside such core dumps will be useful when:

- Comparing number of objects by type on the managed heap
- Analyzing object roots
- Finding what objects have a reference to what type
- Other statistical analysis about objects on the heap

Once the data is generated the file can be exported outside of the machine where it was created, and it can be analyzed in PerfView or in Visual Studio.

To install this tool, you need to run the following command:

```dotnetcli
dotnet tool install -g dotnet-gcdump
```

We will use to generate some reports for .NET Core heaps in the upcoming lab sections.

## dotnet-symbol

[dotnet-symbol](/dotnet/core/diagnostics/dotnet-symbol) is a useful tool for getting symbols for managed debugging and was introduced in .NET Core 2.1 or later. Just like the two other tools detailed above, these tools also require .NET Core SDK to be installed.

dotnet-symbol downloads all the files needed for debugging (symbols, modules, SOS, and DAC for the coreclr module) for any given core dump.

To install this tool, you need to run the following command:

```dotnetcli
dotnet tool install -g dotnet-symbol
```

We will use this tool to configure debugger in the upcoming lab sections.

## procdump

[A linux version of procdump](https://github.com/Sysinternals/ProcDump-for-Linux) is also available with some limited feature sets compared to its Windows counterpart. It does not support every feature the Windows version has. For example, it cannot be configured to collect core dumps when the process crashes or throws a first chance exception.

However it is still a powerful tool. The following command-line options should give you a preview of what it can be used for:

```cmd
-C: Trigger core dump generation when CPU exceeds or equals specified value (0 to 100 * nCPU)
-c: Trigger core dump generation when CPU is less than specified value (0 to 100 * nCPU)
-M: Trigger core dump generation when memory commit exceeds or equals specified value (MB)
-m: Trigger core dump generation when when memory commit is less than specified value (MB)
-T: Trigger when thread count exceeds or equals specified value.
-F: Trigger when filedescriptor count exceeds or equals specified value.
```

Follow the [installation instructions](https://github.com/Sysinternals/ProcDump-for-Linux/blob/master/INSTALL.md) to install procdump in your environment.

We will use this tool to capture a core dump based on CPU usage in the upcoming lab sections.

## A note about selecting the SDK version to use

By default, the SDK installs in a "side-by-side" which means multiple versions can run together on a single machine. How the version gets picked when you're running CLI commands is explained in more detail in the [Select the .NET Core version to use](/dotnet/core/versions/selection) article. As explained in the article the process for selecting an SDK version can be summarized like below:

- dotnet searches for a *global.json* file iteratively reverse navigating the path upward from the current working directory.
- dotnet uses the SDK specified in the first *global.json* found.
- dotnet uses the latest installed SDK if no *global.json* is found.

For example, on the test Linux virtual machine you should have both the .NET Core 3.1 and 5.0 SDKs installed. If you run dotnet with --version switch, you should see that the latest version is being used:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/list.png" alt-text="BuggyAmb list" border="true":::

Now create a *global.json* file in the current directory, which is your home directory and set the version explicitly using the cat tool as shown below. Then check the version once again and it is now showing the exact SDK version you placed inside the *global.json* file:

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/json.png" alt-text="BuggyAmb json" border="true":::

This is important to know when you run some SDK commands such as creating new application with dotnet new command. However, mostly you won't need to do this when working with dotnet-dump and dotnet-gcdump tools.

.NET Core SDK will install the latest version of the tools no matter which SDK you have selected. For example, if you have executed the commands to install the dotnet-dump, dotnet-gcdump and dotnet-symbol tools when the .NET Core SDK 3.1 is selected, the latest versions of these tools will be downloaded and installed as seen in the screenshot below (where version 5 of the tools for dotnet-dump and dotnet-gcdump have been installed):

:::image type="content" source="./media/3-3-debuggers-collect-core-dumps/tool.png" alt-text="BuggyAmb tool" border="true":::

Following articles are great resources to continue reading about .NET tools:

- [How to manage .NET tools](/dotnet/core/tools/global-tools)

- [dotnet tool install](/dotnet/core/tools/dotnet-tool-install)

> [!NOTE]
> Selecting the runtime version to use is different than selecting the SDK version. If you want to use a specific version of the .NET Runtime, use the **--fx-version \<VERSION>** option as explained in [this article](/dotnet/core/tools/).

You are now ready to continue with troubleshooting labs. You will learn how to use these tools to troubleshoot problems in the next chapters.
