---
title: Open and analyze system-generated core dump files
description: This article describes how to install and configure the lldb debugger in Linux, and then open and analyze system-generated .NET Core dump files in lldb debugger.
ms.date: 04/07/2021
ms.prod: aspnet-core
ms.reviewer: ramakoni
---
# Lab 1.2 Troubleshooting crashes - analyzing system-generated core dump files in lldb debugger

_Applies to:_ &nbsp; .NET Core 2.1, .NET Core 3.1  

This article discusses how to install and configure the lldb debugger in Linux, and then open and analyze system-generated .NET Core dump files.

## Prerequisites

The minimum requirement to follow these troubleshooting labs is to have an ASP.NET Core application to demonstrate low-CPU and high-CPU performance problems.

You can find several sample applications to achieve this goal on the internet. For example, you can download and set up [Microsoft's simple webapi sample](/samples/dotnet/samples/diagnostic-scenarios/) to demonstrate undesirable behavior. Or, you can use BuggyAmb ASP.NET Core application as the sample project.

If you have followed the previous parts of this series, you should have the following setup ready to go:

- Nginx is configured to host two websites:
  - The first listens for requests by using the **myfirstwebsite** host header (`http://myfirstwebsite`) and routing requests to the demo ASP.NET Core application that listens on port 5000.
  - The second listens for requests by using **buggyamb** host header (`http://buggyamb`) and routing requests to the second ASP.NET Core sample buggy application that listens on port 5001.
- Both ASP.NET Core applications should be running as services that restart automatically when the server is restarted or the application stops responding.
- The Linux local firewall is enabled and configured to allow SSH and HTTP traffic.

> [!NOTE]
> If your setup is not ready, please visit the "[Part 2 Create and run ASP.NET Core apps](2-1-create-configure-aspnet-core-applications.md)".

To continue this lab, you must have at least one problematic ASP.NET Core web application running behind Nginx.

## Goal of this lab

This article is the second of two lab parts for debugging crashes of ASP.NET Core applications on Linux.

In [part 1](lab-1-1-reproduce-troubleshoot.md), you followed the steps to reproduce a crash problem, and started troubleshooting. You checked Nginx and the system logs, and proceeded to troubleshoot by gathering and analyzing a memory dump file. You extracted the crash core dump file that was generated by apport, Ubuntu's core dump file manager.

In this part, you will install and configure the lldb debugger to work together with the .NET Core debugger extension that's named SOS, and then open the dump file in lldb to analyze it.

## Installing lldb

For this lab, you must install lldb 3.9 or a later version. Instructions for several Linux distros are detailed in [this article](https://github.com/dotnet/diagnostics/blob/main/documentation/lldb/linux-instructions.md). For this section, we recommend you use the `apt` install command: `sudo apt install lldb`. In the next screenshot, you can see that the lldb-6.0 is installed together with some dependencies.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/sudo.png" alt-text="BuggyAmb sudo" border="true":::

After the installation is finished, you have to configure lldb so that it can automatically load SOS when a core dump file is opened.

## Configuring lldb

Before you open the core dump file in lldb, follow these required steps to set the symbol path, download the symbols, and load the **SOS** automatically when lldb is opened:

1. Install the dotnet-symbol tool: 

   > `dotnet tool install -g dotnet-symbol`

1. Download the symbols for the target dump file: 

   > `dotnet-symbol <path_of_dump_file>`

1. Install SOS:

    1. Install the dotnet-sos global tool:
  
       > `dotnet tool install -g dotnet-sos`

    2. Install SOS:   
  
       > `dotnet-sos install`

## Installing the dotnet-symbol tool

You should have already installed the dotnet-symbol tool together with dotnet-dump and dotnet-gcdump tools in the previous part. If you have not installed these tools yet, install them before you proceed. To do this, run the `dotnet tool install -g dotnet-symbol` command to install dotnet-symbols. The, install dotnet-dump and dotnet-gcdump, if you haven't already done this. You should now have three tools installed, as shown in the next screenshot.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/list.png" alt-text="BuggyAmb list" border="true":::

## Downloading symbols for the dump file

In [part 1](lab-1-1-reproduce-troubleshoot.md), you were instructed how to unpack the core dump file from the apport report. Now it's time to download the symbol files. As explained in [this article](/dotnet/core/diagnostics/symbols), at a very high level symbols are mappings between the source code and the binaries. These mappings are used by debuggers to resolve the function or method names, source line information or local variable names when looking at a call stack.

You will use the `dotnet-symbol ~/dumps/dotnet/CoreDump -o ~/dumps/symbols --host-only` command to download the symbols for the memory dump file to the *:::no-loc text="~/dumps/symbols":::* directory.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/dumps.png" alt-text="BuggyAmb dumps" border="true":::

You may receive several "HTTP 404 not found" error messages when you download symbol files if you don't add the `--host-only` switch. You can safely ignore these messages. The `--host-only` parameter will download only the host program. This is all that lldb needs to start debugging the ASP.NET Core application.

The next step is to install the SOS-managed debugging extension. This will expose the .NET debugging commands that are required to run the analysis.

## Installing SOS

What is SOS? According to the [official documentation](https://github.com/dotnet/diagnostics/blob/main/documentation/sos.md), SOS is a debugger extension that allows a developer to inspect the managed state of a .NET application, including the ASP.NET Core and other .NET based applications such as .NET WPF and .NET Windows Forms. It is a cross-platform extension and can be loaded by WinDbg or cdb debugger on Windows and lldb on Linux and MacOS.

To install SOS, you must first install the following dotnet-sos tool:

> `dotnet tool install -g dotnet-sos`

Then, install SOS:

> `dotnet-sos install`

The next screenshot shows the result of a successful installation. Notice that the dotnet-sos tool has configured the lldb debugger so that the SOS extension should be loaded automatically when the debugger starts.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/install.png" alt-text="BuggyAmb install" border="true":::

You are finally ready to open the dump file by using lldb.

## Opening core dump in lldb

To open the core dump, you have to use lldb and the following syntax:

```cmd
lldb --core <dump path> <host-program>
```

The `<host-program>` is the native program that started the .NET Core application. This is usually dotnet, unless the application is self-contained. If this is a self-contained application, then this variable is the name of the application without the *.dll* extension.

 Assuming you are following along by using the same folder names, the path to the memory dump file that you generated in the previous section should be `~/dumps/dotnet/CoreDump`. Therefore, you'll run `lldb --core ~/dumps/dotnet/CoreDump` to open the file.

The next screenshot shows the lldb debugger that has opened the memory dump file.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/lldb.png" alt-text="BuggyAmb lldb" border="true":::

## Setting symbols

Recall that you downloaded the symbol files by using the `dotnet-symbol` command in the *:::no-loc text="~/dumps/symbols":::* directory. The first command that you should run inside the debugger is to set the symbol server path to the directory that you set for the symbol downloads:

```cmd
setsymbolserver -directory ~/dumps/symbols
```

Next, load the symbols: `loadsymbols`

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/loadsymbols.png" alt-text="BuggyAmb loadsymbols" border="true":::

## Running lldb and SOS commands

There are several lldb commands. You can list these by using the `help` command. In the list, you can see that the SOS commands are also listed under **user defined commands**. SOS is a plugin for lldb. You can retrieve plugin help information by using the same `help` command.

> [!NOTE]
> You might want to clear the lldb output occasionally. To do this, press Ctrl+L.

To begin, look at the thread's native call stack by using the `bt` ("back trace") command. This command shows the call stack of the active thread.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/bt.png" alt-text="BuggyAmb bt" border="true":::

Next, examine the managed call stack by using the SOS `clrstack` command.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/clrstack.png" alt-text="BuggyAmb clrstack" border="true":::

You should not be able to retrieve any information. The stack walk will fail because the reported stack is incomplete. This is related to what was discussed before: The auto-generated core dump file can't collect all managed states.

Also recall that an exception occurred, and this caused the process to crash. Take a look at the exception information by running the SOS `pe` command.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/pe.png" alt-text="BuggyAmb pe" border="true":::

As you can see from the output, the `pe` command displays the information about the last exception thrown in the current thread, if there is any.

In our case, we can see the exception message, which is **resource temporarily unavailable** in our case, but the type of the exception and the function names are not resolved. Instead their values are indicated as **unknown**.

The address of the exception is also displayed, and you can try passing this address as a parameter in the pe command to see if you can get more details. Now, run `pe 00007F8244048538` (replacing this address with the address that's displayed in the dump file). Notice, however, that this won't help your investigation much because the function names are still listed as **unknown**.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/unknow.png" alt-text="BuggyAmb unknow" border="true":::

Even if you want to display the objects that are referenced in the stack, you see the same value of **unknown**.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/dso.png" alt-text="BuggyAmb dso" border="true":::

You can try to retrieve more information by selecting an address of one of the objects on the stack, and reviewing the object by using the `dumpobj <address>` command.

:::image type="content" source="./media/lab-1-2-analyze-core-dumps-lldb-debugger/dumpobj.png" alt-text="BuggyAmb dumpobj" border="true":::

However, you will likely conclude that this command will also have a limited effect because it returns only more unknown messages. It's time to stop working with the auto-generated dump file. Run the `exit` command to end the lldb session.

To summarize, the dump file that's generated by system gives you some information, but you're still missing some important information. In the next part, you will be presented the recommended approach to capture a crash dump.

## Next steps

[Lab 1.3 Troubleshooting a crash problem - Capturing core crash dumps with createdump tool](lab-1-3-capture-core-crash-dumps.md)
