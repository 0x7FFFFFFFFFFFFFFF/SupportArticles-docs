---
title: Reproduce the crash problem and start to troubleshoot
description: This article describes the process of reproducing the .NET Core crash problem in Linux and check Nginx tool and system logs to search for the symptoms and indicators of the crash.
ms.date: 04/07/2021
ms.prod: aspnet-core
ms.reviewer: ramakoni
---
# Lab 1.1 Troubleshooting a crash problem - Reproducing the crash problem and starting to troubleshoot

_Applies to:_ &nbsp; .NET Core 2.1, .NET Core 3.1  

This article introduces the process of reproducing the .NET Core crash problem in Linux and check Nginx tool and system logs to search for the symptoms and indicators of the crash.

## Prerequisites

The minimum requirement to follow these troubleshooting labs is to have an ASP.NET Core application that demonstrates low and high CPU performance problems and crash issues.

You may find several sample applications that achieve these goals on the Internet. For example, you may download, set up and use [Microsoft's simple webapi sample](/samples/dotnet/samples/diagnostic-scenarios/) which demonstrates undesirable behaviors. Or, you can use BuggyAmb ASP.NET Core application for the sample project.

If you have followed the previous parts of these series up to this point, you should have the following setup ready to continue:

- Nginx configured to host two websites:
  - The first web site listening for requests with the **myfirstwebsite** host header (`http://myfirstwebsite`) and routing the requests to the demo ASP.NET Core application, which is listening on port 5000.
  - The second web site listening for requests with host header **buggyamb** (`http://buggyamb`) and routing the requests to the second ASP.NET Core sample buggy application, which is listening on port 5001.
- Both ASP.NET Core applications should be running as services, which restart automatically when the server is rebooted, or the applications stops or crashes.
- Linux local firewall is enabled and configured to allow SSH and HTTP traffic.

> [!NOTE]
> If your set up is not ready, there is a quick Linux installation guide to run BuggyAmb behind Nginx here.

In order to continue with the lab, you will need to have at least one problematic ASP.NET Core web application running behind Nginx.

## Goal of this lab

This lab work is divided into two parts and this is the first part:

- Part 1: Reproducing the crash problem and collecting data. In this part, you will first reproduce the crash issue, check Nginx and system logs to search for the symptoms and indicators of the crash, the proceed with troubleshooting by generating a crash dump. This part will end by gathering the system generated core dump from the crash report generated by Ubuntu's manager, Apport.

- [Part 2](lab-1-2-analyze-core-dumps-lldb-debugger.md): In the next part, you install and configure lldb to work with .NET Core debugger extension called SOS. You will also open the dump in lldb and analyze it.

## Reproducing a crash problem

When browsing to the url of the site, `http://buggyamb/`, and clicking the Problem Pages link you will see links to some problem scenarios. There are three different crash scenarios, however, for this lab you are going to troubleshoot the third crash scenario:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/crash.png" alt-text="BuggyAmb crash" border="true":::

Before clicking any link, click the Expected Results and confirm that your application is working fine. You should see an output like the one illustrated below:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/output.png" alt-text="BuggyAmb output" border="true":::

The page should load fast (under one second) and will display a list of products.

To test the first slow page scenario, please click the **Slow** link. The page will eventually show the same output as Expected Results page but this time it the page will render much slower when compared with the expected behavior.

Before reproducing the crash problem make a note of the process ID of the buggy application. You will use this information to confirm if our application restarts. We run the `systemctl status buggyamb.service` command to get the current PID. In the results below, the PID of the process running the service is: 2255.

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/service.png" alt-text="BuggyAmb service" border="true":::

Now click the **Crash 3** link. The page loads and displays a message like the below:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/crash3.png" alt-text="BuggyAmb crash3" border="true":::

That message asks the user to ponder the following question: will this page cause the process to crash? Run the same `systemctl status buggyamb.service` command and you will note that the PID is same. Hence a crash has not occurred.

Click the **Expected Results** link and then **Slow** link. You will see the correct page after clicking the **Expected Results** hyperlink, but you should receive the following error when clicking the **Slow** hyperlink:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/slow.png" alt-text="BuggyAmb slow" border="true":::

Even if you click any other link on the website you will get the same error for some time. After 10 - 15 seconds, everything will start responding again as expected.

To check if the PID is changed, run the `same systemctl status buggyamb.service` command. This time you should notice that the process seems to really have crashed because the PID is changed. In the example above, the process PID was 2255 and it in the illustration below it is now 2943. It seems that the website made good on its promise to crash the process.

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/service2943.png" alt-text="BuggyAmb service2943" border="true":::

## Troubleshooting

This is the summary of repro steps:

- Click **Crash 3**, the page loads fine with 'confusing message' suggesting that the process will crash.
- Now click **Slow** and you get an HTTP 502 - Bad Gateway error instead of the product table.
- Once the issue starts, none of the pages render for the next 10 - 15 seconds.
- After 10 - 15 seconds the application starts responding fine.

HTTP 502 - Bad Gateway error message itself does not tell much but should provide a first clue: this is a proxy error, and it may happen if a proxy cannot communicate with the application running behind proxy. In the proposed setup, Nginx is working as a reverse proxy to the ASP.NET Core application: hence, maybe this error coming from Nginx is indicating that it was not able to reach the backend application when forwarding incoming requests.

## Confirming that Nginx works fine

As a first step you may want to check if Nginx is working correctly. This step is not mandatory because you know that the application is crashing but confirm anyway by checking Nginx logs - you already practiced similar troubleshooting steps before in the [Installing and configuring Nginx](2-2-install-nginx-configure-it-reverse-proxy.md) section.

Nginx has two kinds of logs: access logs and error logs. Those are stored under *:::no-loc text="/var/log/nginx/":::* directory.

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/log.png" alt-text="BuggyAmb log" border="true":::

Access logs are just like IIS log files. Open them and take a quick look just like in the previous section. They do not show any new information other than HTTP 502 response status code, which you already encountered during the navigation attempts on the site's pages.

Inspect at the **error logs** using the `cat /var/log/nginx/error.log` command. This log is more helpful and clear, Nginx was able to process the request but the connection between Nginx and the buggy application is closed before getting the final response:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/error.png" alt-text="BuggyAmb error" border="true":::

This log clearly indicates that this is not a Nginx problem.

## Checking system logs - journalctl command

If the ASP.NET Core application is crashing, then there should be symptoms somewhere.

Since the buggy application is running as a systemd service, its operation is logged in the system log files. System log files are like system event logs in Windows. The `journalctl` command is used to view and manipulate systemd logs.

In its simple form, you can just run `journalctl` command and see all of the logs but the output will be a large file. It is in your best interest to learn how to filter it through the content. You can use the following command:

```cmd
journalctl -r --identifier=buggyamb-identifier --since "10 minute ago"
```

Underneath is an explanation of the switches used:

- `-r`: Print the logs in reverse order so the newest are listed first.
- `--identifier`: Remember the `SyslogIdentifier=buggyamb-identifier` line in the service file of the test application? This tag can be used to filter the logs to only show entries pertaining to the problematic application.
- `--since`: It is a filter with an obvious meaning: `--since "10 minute ago"` means "show me the information logged in the last 10 minutes", or you can use `--since "2 hour ago"` to see the information logged in the last two hours.

It is recommended you consult the help page for `journalctl` command by running man journalctl should you wish to familiarize yourself more in depth with this command. There are several useful switches that can help filtering the logs.

We will not focus on the power of `journalctl` but it is your responsibility to learn about it :)

Run the `journalctl -r --identifier=buggyamb-identifier --since today -o cat` command and notice there are some warnings:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/cat.png" alt-text="BuggyAmb cat" border="true":::

To see the details, scroll down and right using arrow keys and we find a `System.Net.WebException` exception:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/webexception.png" alt-text="BuggyAmb webexception" border="true":::

If you look at the logs closely, you will see the code file name and the line number on which the problem occurred. For the purposes of this lab, we will presume that this information is not available. In real world scenarios, you may not be able to retrieve this type of information, hence the objective is to continue by analyzing a crash dump to find out the reason behind the crash.

## Getting core dump after crash

Remember some of system's key behaviors when a process is terminated:

- By default, a core dump is generated.
- Core dump is named as *core* and is created in current the working directory or in *:::no-loc text="/var/lib/systemd/coredump":::* directory.

Although the default behavior is for the system to generate core dump, this setting can be overwritten in *:::no-loc text="/proc/sys/kernel/core_pattern":::* to directly pipe the resulting core dump into another application. When using Ubuntu the previous sections in this series discussed that Apport manages core dump generation in Ubuntu - the `core_pattern` file is overwritten to pipe the core dump to apport:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/core.png" alt-text="BuggyAmb core" border="true":::

Apport uses *:::no-loc text="/var/crash":::* directory to store core its report files. If you inspect this directory, you should see a file that was already generated after crash:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/varcrash.png" alt-text="BuggyAmb varcrash" border="true":::

However, this is not the core dump file, this is a report file that contains several pieces of information along with the dump file and you have to unpack this file to get the core dump file.

Create a dumps directory under your home directory and you be instructed on how to extract the report there. The command for unpacking apport report file is apport-unpack. Simply run the `sudo apport-unpack /var/crash/_usr_share_dotnet_dotnet.33.crash ~/dumps/dotnet` command.

> [!NOTE]
> The `/dumps` directory is created but `/dumps/dotnet` directory will be created by `apport-unpack` command. Here is the result:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/sudo.png" alt-text="BuggyAmb sudo" border="true":::

If you check the `~/dumps/dotnet` folder, you should be seeing the dump file there. It is CoreDump and its size should be around 191 MB:

:::image type="content" source="./media/lab-1-1-reproduce-troubleshoot/dump.png" alt-text="BuggyAmb dump" border="true":::

It may be a cumbersome process to get and extract the auto-generated core dump file. Luckily it will be easier to capture core dumps with `createdump` in the next lab but first continue to [part 2](lab-1-2-analyze-core-dumps-lldb-debugger.md) of this lab to see how to open this dump in lldb debugger and do a quick analysis.

## Next steps

[Lab 1.2 Opening and analyzing system generated core dump in lldb debugger](lab-1-2-analyze-core-dumps-lldb-debugger.md)
